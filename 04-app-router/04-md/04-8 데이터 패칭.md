# section04-08 앱 라우터의 데이터 패칭

## Page Router 버전의 데이터 패칭과정 미리 살펴보기

- 기존에는 사전 렌더링 과정 중에 넥스트 서버 사이드에서 백엔드 서버나 DB로부터
  데이터를 패칭해오기 위해 페이지 역할을 하는 파일 안에 SSR을 의미하는
  getServerSideProps나 ISR · SSG를 의미하는 getStaticPorps나
  동적 경로를 갖는 Dynamic SSG 페이지를 생성하기 위한 getStaticPath 등의
  오직 서버측에서만 실행되는 함수들을 이용했었음

### 데이터 패칭 (in Page Router) : getServerSideProps

- 서버 컴포넌트라는 개념이 없기때문에 모든 컴포넌트가 다 클라이언트 컴포넌트로 동작함
- Page 컴포넌트 또한 클라이언트 컴포넌트로서 브라우저에서도 동일하게 한번 더 실행됨

```tsx
// 서버에서만 실행 됨
export async function getServerSideProps() {
  const data = await fetch("...");

  return { props: { data } }; // data -> page의 Props로 넘어감
}

// 클라이언트 컴포넌트 서버와 클라이언트 모두 실행 됨
export function Page(props) {
  return <div>...</div>;
}
```

- 즉 Page Router 버전의 넥스트 앱에서는 페이지 컴포넌트 안에 데이터 패칭로직을
  직접 작성하게 되면 해당 로직은 서버 측에서만 실행되는게 아니라
  브라우저에서 하이드레이션 과정에서 한번 더 실행이 됨
- 데이터를 불러오기 위해서는 getServerSideProps나 GetStaticProps 등의 특수한 함수를 이용했어야 함
- 서버에서만 실행된 패치 함수는 최상단 루트인 Page 컴포넌트에게만 전달되기때문에,
  props를 하위 컴포넌트에서 쓰려면 props를 직접 넘겨주거나 컨텍스트API 등을 활용해 데이터를 넘겼어야 함
  → **App Router에서는 서버 컴포넌트가 추가**되면서 이렇게 하지 않아도됨!

## App Router 버전의 데이터 패칭과정 미리 살펴보기

```tsx
export async function Page(props) {
  const data = await fetch("....");
  return <div>...</div>;
}
```

- 서버 컴포넌트는 서버에서만 실행 되기 때문에 **async**키워드를 붙여
  서버 컴포넌트를 비동기 함수로 만든 다음에, 해당 컴포넌트 내부에서 **await**키워드와
  **fetch** 메서드를 활용해 데이터를 직접 불러오도록 하는 데이터 패칭 로직을 작성 할 수 있다.

- 원래 리엑트 컴포넌트에서의 클라이언트 컴포넌트들은 async를 사용해 비동기 함수로 설정할 수 없었음
- 이렇게 된 이유는 클라이언트 컴포넌트들은 브라우저에서도 똑같이 동작해야 하기 때문에 async를 붙혀
  비동기로 동작하게 설정할 경우에는 props의 전달이나 memoization(useMemo, useCallback 등)을 사용하는
  차원에서 여러 문제를 일으킬 수 있기 때문임
- 서버컴포넌트는 브라우저에서 실행되지 않기때문에 서버 컴포넌트에서는 async 키워드를 붙여서
  비동기 함수로 사용해도 아무런 문제가 발생하지 않음
- 페이지 라우터에서 사용하던 기존의 함수들을 쓰지않고 ≓ getServerSideProps, getStaticPorps...를 대체
  컴포넌트 내부에서 직접 필요로 하는 데이터를 불러와 바로 렌더링 할수있도록 데이터를 fetching 하는 방식으로 변경됨
- 따라서 fetch 된 데이터를 더이상 props나 컨텍스트 API를 활용해 넘겨줄 필요가 없어짐
  ≓ 데이터가 필요한 컴포넌트가 있다면 해당하는 컴포넌트가 직접 데이터를 요청
- 페이지의 컴포넌트 구조가 아주 복잡해도 큰 무리 없이 데이터 패칭을 구현할 수 있음

## App Router 데이터 패칭

- 페이지 컴포넌트에 async 키워드 붙혀준뒤
  await fetch('...') 함수써서 데이터 패칭

```tsx
export default async function Home() {
  const response = await fetch("http://localhost:12345/book");
  const allBooks = await response.json();
  // ⭐ 서버에서만 실행돼서 콘솔도 서버에서만!
  console.log(allBooks);

```

- 패치를 두번써야 되는 경우에는
  불러와야 되는 데이터에 따라 컴포넌트를 각각 나눠주는게 좋음
  ├─ 지금 추천하는 도서, 등록된 모든 도서를 한페이지에서 보여주는 경우
  └─ 추천하는 도서 불러오는 컴포넌트 + 등록된 도서 불러오는 컴포넌트 분리

### API 환경변수 만들기

```bash
section04/
   └─ .env -> 환경변수 파일

# .env
NEXT_PUBLIC_API_SERVER_URL=http://localhost:12345
```

### 패치 두번하는경우 (컴포넌트 분리) & API 환경변수 이용하기

```tsx
import BookItem from "@/components/book-item";
import style from "./page.module.css";
import type { Book } from "@/types/book";

const BASE_URL = process.env.NEXT_PUBLIC_API_SERVER_URL;
if (!BASE_URL) {
  throw new Error("API SERVER URL이 설정되지 않았습니다.");
}

// 모든 도서 컴포넌트 (분리 1)
async function AllBooks() {
  const response = await fetch(`${BASE_URL}/book`);
  // fetch 예외처리 필수 !⭐⭐⭐
  if (!response.ok) {
    return <div>등록 도서 오류 발생 ❌</div>;
  }
  const allBooks: Book[] = await response.json();

  return (
    <div>
      {allBooks.map((book) => (
        <BookItem key={book.id} {...book} />
      ))}
    </div>
  );
}
// 추천 도서 컴포넌트 (분리 2)
async function RecoBooks() {
  const response = await fetch(`${BASE_URL}/book/random`);
  if (!response.ok) {
    return <div>등록 도서 오류 발생 ❌</div>;
  }
  const recoBooks: Book[] = await response.json();

  return (
    <div>
      {recoBooks.map((book) => (
        <BookItem key={book.id} {...book} />
      ))}
    </div>
  );
}

export default function Home() {
  // const allBook = await apiFetch<Book[]>("/book");
  return (
    <div className={style.container}>
      <section>
        <h3>지금 추천하는 도서</h3>
        <RecoBooks /> -> 분리 컴포넌트 사용
      </section>
      <section>
        <h3>등록된 모든 도서</h3>
        <AllBooks /> -> 분리 컴포넌트 사용
      </section>
    </div>
  );
}

```

### 환경변수 파일 주의점

- 환경 변수 이름앞에 **NEXT_PUBLIC** 접두사를 붙지 않으면 넥스트는
  자동으로 서버 측에서만 활용할 수 있게 프라이빗 설정으로 해버림
- 따라서 접두사를 쓰지않으면 클라이언트 컴포넌트에서는 접근 조차 불가능해져버림

### searchParam 이용하여 데이터 패칭하기

```tsx
import BookItem from "@/components/book-item";
import { API_SERVER_URL } from "@/app/lib/env";
import { Book } from "@/types/book";

export default async function Page({
  searchParams,
}: {
  searchParams: Promise<{ q?: string }>;
}) {
  const { q } = await searchParams;

  const response = await fetch(`${API_SERVER_URL}/book/search?q=${q}`);
  if (!response.ok) {
    return <div>오류가 발생했습니다</div>;
  }

  const books: Book[] = await response.json();
  return (
    <div>
      {books.map((book) => (
        <BookItem key={book.id} {...book} />
      ))}
    </div>
  );
}
```

### 동적 파라미터 이용하여 데이터 패칭

```tsx
import { API_SERVER_URL } from "@/app/lib/env";
import { Book } from "@/types/book";
import style from "./page.module.css";

export default async function Page({
  params,
}: {
  params: Promise<{ id: string | string[] }>;
}) {
  const { id } = await params;

  const response = await fetch(`${API_SERVER_URL}/book/${id}`);
  if (!response.ok) {
    return <div>오류가 발생했습니다.</div>;
  }

  const book: Book[] = await response.json();
  const { title, subTitle, description, author, publisher, coverImgUrl } = book;

  return (
    <div className={style.container}>
      <div
        className={style.cover_img_container}
        style={{ backgroundImage: `url('${coverImgUrl}')` }}
      >
        <img src={coverImgUrl} />
      </div>
      <div className={style.title}>{title}</div>
      <div className={style.subTitle}>{subTitle}</div>
      <div className={style.author}>
        {author} | {publisher}
      </div>
      <div className={style.description}>{description}</div>
    </div>
  );
}
```

## 정리

- 앱라우터 버전의 넥스트 앱에서는 데이터를 어떻게 패칭해올수있는지 학습함
- 서버 컴포넌트가 있기때문에 해당하는 서버 컴포넌트에
  **async** 키워드를 붙여서 비동기 함수로 만들어서 해당 컴포넌트 내부에서
  직접 패칭해 올 수 있다
