# section04-05 리액트 서버 컴포넌트 주의사항

## 꼭 숙지해야 할 4가지 주의사항들

- 1. 서버 컴포넌트에는 브라우저에서 실행될 코드가 포함되면 안된다.

- 2. 클라이언트 컴포넌트는 클라이언트에서만 실행되는 개념이 아니다.

- 3. 클라이언트 컴포넌트에서 서버 컴포넌트를 import 할 수 없다.

- 4. 서버 컴포넌트에서 클라이언트 컴포넌트에게 직렬화 되지 않은 Props는 전달 불가하다.

### 1. 서버 컴포넌트에는 브라우저에서 실행될 코드가 포함되면 안된다.

```tsx
//  src/app/page.tsx
/** ❌ 브라우저에서 실행되는 기능을 담는 라이브러리 사용 불가능*
 *  import someLib from "somLib";
 * /

export default function Home() {
  /**
   * ❌ react hook들, onClick, onChange 등의 이벤트 핸들러들은
   * 서버 컴포넌트에서 사용 불가능
   */
  return <div>인덱스 페이지</div>;
}
```

- 라이브러리에 대한 코드에도 에러가 나타나기때문에 각별히 주의

### 2. 클라이언트 컴포넌트는 클라이언트에서만 실행되지 않는다.

- 클라이언트 컴포넌트는 지금까지 줄곧 사용해오고 있었던,
  페이지 라우터 버전에서도 똑같이 쓰고 있던 일반적인 컴포넌트들을 말하는 것임

- 사전 렌더링을 위해 서버에서 1번 실행
- 하이드레이션을 위해 브라우저에서 1번 실행
  └── 서버와 클라이언트에서 모두 실행됨

  ```tsx
  "use client";
  export default function Home() {
    console.log("컴포넌트 실행"); // 서버측, 브라우저측 한번씩 실행됨
  }
  return <div>인덱스 페이지</div>;
  ```

### 3. 클라이언트 컴포넌트에서 서버 컴포넌트를 import할 수 없다.

```tsx
"use client";
import ServerComponent form './server-component.tsx'; // ❌ 불가

export default function ClientComponent() {
  return <ServerComponent /> // ❌ 불가
}

```

- 서버컴포넌트는 오직 서버에서만 딱 한번 실행되기 때문에
  클라이언트측에서 실행할 땐 (하이드레이션을 위해서 실행)될땐 서버컴포넌트의 코드는 존재하지 않음
  └──서버컴포넌트는 브라우저에게 전달조차 되지 않기때문에 브라우저에서는 코드 존재하지 않음
- 없는 코드를 import 하려하니까 안됨

#### 실수로 클라이언트 컴포넌트에서 서버 컴포넌트를 import 했을때

- Next.js에서 서버 컴포넌트를 자동으로 클라이언트 컴포넌트로 바꿔버림
- 이렇게 되면 불필요한 컴포넌트도 JS번들에 포함되기때문에 이런 방법은 최대한 피해야함

#### 어쩔 수 없이 클라이언트 컴포넌트에서 서버 컴포넌트를 자식으로 둬야한다면?

- 클라이언트 컴포넌트에서 children으로 받아서 렌더링 시켜주는 방법을 쓰자

  <!-- client-component.tsx -->

  ```tsx
  "use client";

  export default function ClientComponent({
    children,
  }: {
    children: ReactNode;
  }) {
    return <div>{children}</div>;
  }
  ```

  <!-- page.tsx -->

  ```tsx
  export default function Home() {
    return (
      <div>
        인덱스 페이지
        <ClientComponent>
          <ServerComponent /> /** 클라이언트 컴포넌트로 변경되지 않음*/
        </ClientComponent>
      </div>
    );
  }
  ```

#### 4. 서버 컴포넌트에서 클라이언트 컴포넌트에게 직렬화 되지 않는 Props는 전달 불가하다.

- 직렬화란?
  : 객체, 배열, 클래스 등의 복잡한 구조의 데이터를 네트워크 상으로 전송하기 위해
  아주 단순한 형태(문자열,Byte)로 변환하는 것

  <!-- Before -->

  ```js
  const person = {
    name: "이정환",
    age: 27,
  };
  ```

  <!-- After -->

  ```js
  {"name":"이정환","age":27}
  ```

- 자바스크립트의 함수는 아주 특별하게 직렬화가 불가능함

  - 자바스크립트 함수는 값이 아닌 코드블럭들을 포함하고 있는 특수한 형태를 가지고 있기도 하고,
    크로저나 렉시컬 스코프 등의 다양한 환경에 의존해 있는 경우가 많기 때문에 모든 정보들을 단순한 문자열이나 바이트의 형태로 표현할 수 없음
    ```js
    function func() {
      console.log("함수는 직렬화 X");
    }
    ```

- 따라서 서버컴포넌트에서 클라이언트 컴포넌트로 향하는 Props가 될 수 없음
- 서버에서 컴포넌트들의 RSC Payload (React Server Component 직렬화된 결과물) 을 만들어야 하는데,
  이때 함수라는 값은 직렬화가 불가능한 값이기때문에 런타임오류 발생
