# section04-04 리엑트 서버 컴포넌트 이해하기

## React Sever Component

- 리액트 18 버전부터 새롭게 추가된 새로운 유형의 리액트 컴포넌트
- 기존의 컴포넌트들과 달리 오직 서버 측에서만 실행이 되는 컴포넌트를 말함
- 서버가 아닌 브라우저 측에서는 아예 실행이 되지않는 컴포넌트

## 서버 컴포넌트 등장 배경

### Page Router 버전의 Next.js에는 어떤 문제가 있었을까?

- 페이지 라우터에서는 사전 렌더링 과정을 거쳐서 사용자가 요청한 페이지를 화면에 최종적으로 렌더링하게 됨
- 사전 렌더링 중에 화면에 수화를 진행하기 위해서 모든 컴포넌트들을 JS 번들로 묶어 후속으로 전달해줌
- JS 번들에 포함이 되어 브라우저에게 전달된 컴포넌트들은 브라우저측에서 수화를 위해 한번 더 실행이 됨
- 페이지 라우터들은 수화가 필요하지 않은 정적인 페이지마저도
  JS 번들에 다 묶어 브라우저에게 전달을 하기때문에 불필요하게 많은 컴포넌트들이 JS 번들에 포함이 될수밖에 없었음
  ≒ JS 번들 불러오는 시간 증가
  ≒ Hydration(수화) 시간 증가
  ≒ TTI 시간 증가

### 그래서 나온 아이디어 ≒ React Sever Component

- 사전렌더링 과정중 불필요한 JS번들을 제외하면 되겠네
  └── JS 번들 용량이 줄어드니까 JS 번들 불러오는 시간, 수화, TTI 시간 전부 감소하겠네
- 상호작용이 없는 컴포넌트들은 클라이언트 측에 전달하지 않도록 다른 유형으로 분류하면 되겠네
  └── **서버측에서만 실행되는 컴포넌트** (브라우저에서 실행 X)

## 서버 컴포넌트와 클라이언트 컴포넌트 차이

### 서버 컴포넌트

- 서버측에서 사전 렌더링을 진행할 때 딱 한번만 실행됨

### 클라이언트 컴포넌트

- 사전 렌더링 진행할때 한번, 하이드레이션 진행할때 한번, 총 2번 실행

### 실행 예시

```tsx
// Sidebar.tsx (Server Component)
export default async function Sidebar() {
  const data = await fetch(...)
  return <aside>{data.title}</aside>
}

// Button.tsx (Client Component)
'use client'
export default function Button() {
  return <button onClick={...}>Click</button>
}
```

- ⭐ 실제 동작 순서

  - 서버:
    Sidebar 실행 → fetch
    → RSC Payload 생성 (React Server Component 트리 결과 직렬화)
    → Button에 대한 Client Component Boundary 정보 포함
  - 클라이언트:
    RSC Payload 수신
    → Sidebar DOM 구성
    → Button 위치에 boundary placeholder 생성
    → Button JS 번들 다운로드
    → Button DOM 구성 + hydration
    → 이벤트 활성화

  참고⭐) Sidebar는 RSC Payload만으로 즉시 DOM이 만들어지고 Button은 JS 번들을 받은 뒤에야 완성된다

## 서버/클라 컴포넌트 구성

- 페이지의 대부분을 서버 컴포넌트로 구성할 것을 권장
- 클라이언트 컴포넌트는 꼭 필요한 경우에만 사용할 것

## 서버 컴포넌트를 장점

```tsx
import styles from "./page.module.css";

export default function Home() {
  console.log("home 컴포넌트 실행"); // 서버에서만 실행됨

  const secretKey = "qwer1234";
  /** 비밀 키값을 컴포넌트 내부에서 사용한다고 하더라도
   *  클라이언트(브라우저) 측에서는 secretKey 코드가 전달조차 되지 않기때문에
   *  전혀 아무런 보안적인 문제도 발생하지 않고,
   *  (이후 쳅터 진행내용) 홈 컴포넌트 안에서 직접 데이터를 불러오는것도 가능함
   *  SSR , SSG 의 역할을 홈 컴포넌트가 그대로 할 수 있게 설정까지 해줄 수 있음
   */

  return <div className={styles.page}>home</div>;
}
```

## 클라이언트 컴포넌트로 설정하기

- 파일 상단에 **"use client"** 지시자 작성해주기

  ```tsx
  "use client";
  import { useEffect } from "react";
  import styles from "./page.module.css";

  export default function Home() {
    useEffect(() => {
      console.log("useEffect는 클라이언트 컴포넌트에서만 사용이 가능합니다.");
    }, []);
    return <div className={styles.page}>home</div>;
  }
  ```

## 서버컴포넌트, 클라이언트 컴포넌트 뭘 보고 구분해서 만들까?

- 상호작용이 있으면 클라이언트 컴포넌트, 아니면 서버 컴포넌트
- 자바스크립트의 기능을 활용하는 (react hook) 경우 클라이언트 컴포넌트
- Link태그의 페이지 이동은 HTML 고유의 기능이기 때문에
  자바스크립트의 기능을 활용하는 상호작용은 아니어서 이런 경우에는 상호작용에 해당되지 않음
- 입력이나, 클릭 같은 이벤트를 처리할 상호작용이 있는경우 클라이언트 컴포넌트

## 파일이름이 page, layout 이 아닌경우

```bash
app/
└─ (with-searchbar)/
   ├─ page.tsx
   ├─ page.module.css
   ├─ layout.tsx
   ├─ searchbar.tsx <-- 이런경우
   └─ search/
      └─ page.tsx


```

- page나 layout이 아니면 일반적인 JS·TS 파일로 간주하기 때문에
  컴포넌트 파일도 앱 폴더 안에 만들어 둬도 된다
- 이런 특징을 Co-Location 이라고 부름
- 페이지마다 필요한 컴포넌트들을 페이지 파일과 함께 모아 둘 수 있는 장점이 있음
